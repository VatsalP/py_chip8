
    """
        if a:
            if type_of == 0x0:

                sub_type_of = (code[0] & 0xf) << 8 | code[1]
                if sub_type_of == 0x0e0:
                    # cls
                    for y in range(32):
                        for x in range(64):
                            self.display[y][x] = 0
                elif sub_type_of == 0x0ee:
                    # ret 
                    self.chip_state.sp -= 1
                    self.chip_state.pc = self.chip_state.memory[self.chip_state.sp] << 8
                    self.chip_state.sp -= 1
                    self.chip_state.pc = self.chip_state.memory[self.chip_state.sp]

            elif type_of == 0x1:
                # jump to address jmp nnn
                addr = (code[0] & 0xf) << 8 | code[1]
                self.chip_state.pc = addr

            elif type_of == 0x2:
                # stack thing
                # call nnn
                addr = (code[0] & 0xf) << 8 | code[1]
                self.chip_state.memory[self.chip_state.sp] = self.chip_state.pc & 0x00ff
                self.chip_state.sp += 1
                self.chip_state.memory[self.chip_state.sp] = (self.chip_state.pc & 0x00ff) >> 8
                self.chip_state.sp += 1
                self.chip_state.pc = addr

            elif type_of == 0x3:
                # ske vx, nn
                if self.chip_state.v[code[0] & 0xf] == code[1]:
                    self.chip_state.pc += 2

            elif type_of == 0x4:
                # skne vx, nn
                if self.chip_state.v[code[0] & 0xf] != code[1]:
                    self.chip_state.pc += 2

            elif type_of == 0x5:
                # ske vx, vy
                if self.chip_state.v[code[0] & 0xf] == self.chip_state.v[code[1] >> 4]:
                    self.chip_state.pc += 2

            elif type_of == 0x6:
                # load vx, nn
                self.chip_state.v[code[0] & 0xf] = code[1]

            elif type_of == 0x7:
                # add vx, nn
                self.chip_state.v[code[0] & 0xf] += code[1]
                self.chip_state.v[code[0] & 0xf] %= 256

            elif type_of == 0x8:
                last_nibble = code[1] & 0xf
                if last_nibble == 0x0:
                    # load vx, vy
                    self.chip_state.v[code[0] & 0xf] = self.chip_state.v[code[1] >> 4]

                elif last_nibble == 0x1:
                    # or vx, vy
                    self.chip_state.v[code[0] & 0xf] |= self.chip_state.v[code[1] >> 4] 
                
                elif last_nibble == 0x2:
                    # and vx, vy
                    self.chip_state.v[code[0] & 0xf] &= self.chip_state.v[code[1] >> 4]

                elif last_nibble == 0x3:
                    # xor vx, vy
                    self.chip_state.v[code[0] & 0xf] ^= self.chip_state.v[code[1] >> 4]

                elif last_nibble == 0x4:
                    # add vx, vy
                    self.chip_state.v[code[0] & 0xf] += self.chip_state.v[code[1] >> 4]
                    if self.chip_state.v[code[0] & 0xf] > 255:
                        self.chip_state.v[0xf] = 0x1
                        self.chip_state.v[code[0] & 0xf] %= 256
                    else:
                        self.chip_state.v[0xf] = 0x0
                    
                elif last_nibble == 0x5:
                    # sub vx, vy - vx -= vy
                    # ipdb.set_trace()
                    self.chip_state.v[code[0] & 0xf] -= self.chip_state.v[code[1] >> 4]
                    if self.chip_state.v[code[0] & 0xf] < 0:
                        self.chip_state.v[0xf] = 0x0
                        self.chip_state.v[code[0] & 0xf] += 256
                    else:
                        self.chip_state.v[0xf] = 0x1

                elif last_nibble == 0x6:
                    # shr vx, vy
                    # bit = self.chip_state.v[code[1] >> 4] & 0x1
                    # self.chip_state.v[code[0] & 0xf] = self.chip_state.v[code[1] >> 4] >> 1
                    # self.chip_state.v[0xf] = bit
                    bit = self.chip_state.v[code[0] & 0xf] & 0x1
                    self.chip_state.v[code[0] & 0xf] = self.chip_state.v[code[0] & 0xf] >> 1
                    self.chip_state.v[0xf] = bit

                elif last_nibble == 0x7:
                    # subn vx, vy - vx = vy - vx
                    result = self.chip_state.v[code[1] >> 4] - self.chip_state.v[code[0] & 0xf]
                    if result < 0:
                        self.chip_state.v[0xf] = 0x0
                        self.chip_state.v[code[0] & 0xf] = 256 + result 
                    else:
                        self.chip_state.v[code[0] & 0xf] = result
                        self.chip_state.v[0xf] = 0x1

                elif last_nibble == 0xE:
                    # shl vx, vy
                    # self.chip_state.v[0xf] = self.chip_state.v[code[1] >> 4] >> 7
                    # self.chip_state.v[code[0] & 0xf] = self.chip_state.v[code[1] >> 4] << 1
                    self.chip_state.v[0xf] = self.chip_state.v[code[0] & 0xf] >> 7
                    self.chip_state.v[code[0] & 0xf] = self.chip_state.v[code[0] & 0xf] << 1

            elif type_of == 0x9:
                # skne vx, vy
                if self.chip_state.v[code[0] & 0xf] != self.chip_state.v[code[1] >> 4]:
                    self.chip_state.pc += 2

            elif type_of == 0xA:
                # load i, nnn
                addr = ((code[0] << 8) | code[1])
                self.chip_state.i = addr

            elif type_of == 0xB:
                # jmp [i] + nnn
                addr = (((code[0] & 0xf) << 8) | code[1]) + self.chip_state.v[0]
                self.chip_state.pc = addr

            elif type_of == 0xC:
                # rand vx, nn
                mask = code[1]
                random_num = random.randint(0, 255) & mask
                self.chip_state.v[code[0] & 0xf] = random_num

            elif type_of == 0xD:
                # drw vx, vy, n
                vx, vy = self.chip_state.v[code[0] &  0xf], self.chip_state.v[code[1] >> 4]
                n = code[1] & 0xf
                unset = False
                for y in range(n):
                    sprite_byte =self.chip_state.memory[
                        self.chip_state.i + y
                    ]
                    # doubt
                    for x in range(8):
                        # addr = ((vy+y) * 64) + vx + x
                        if (vy+y) >= 32 or (vx + x) >= 64:
                            # out of screen
                            continue
                        new_byte = (sprite_byte & (1<<(8-x-1))) >> (8-x-1)
                        old_byte = self.display[vy+y][vx+x]
                        if old_byte and not (old_byte ^ new_byte):
                            unset = True
                        self.display[vy+y][vx+x] = new_byte ^ old_byte
                self.chip_state.v[0xf] = 1 if unset else 0

            elif type_of == 0xE:
                # skips related to key pressed
                import ipdb; ipdb.set_trace()
                if code[1] == 0x9E:
                    # if pressed_keys[self.chip_state.v[KEYS_REVERSED[code[0] & 0xf]]]:
                    #     self.chip_state.pc += 2
                    py_key = KEYS_REVERSED[self.chip_state.v[code[0] & 0xf]]
                    if pressed_keys[py_key]:
                        self.chip_state.pc += 2
                elif code[1] == 0xA1:
                    #if not pressed_keys[[self.chip_state.v[KEYS_REVERSED[code[0] & 0xf]]]]:
                        #self.chip_state.pc += 2
                    py_key = KEYS_REVERSED[self.chip_state.v[code[0] & 0xf]]
                    if not pressed_keys[py_key]:
                        self.chip_state.pc += 2

            elif type_of == 0xF:
                if code[1] == 0x07:
                    self.chip_state.v[code[0] & 0xf] = self.chip_state.delay
                elif code[1] == 0x0A:
                    key = wait()
                    self.chip_state.v[code[0] & 0xf] = KEYS[key]
                elif code[1] == 0x15:
                    self.chip_state.delay = self.chip_state.v[code[0] & 0xf]
                elif code[1] == 0x18:
                    self.chip_state.sound = self.chip_state.v[code[0] & 0xf]
                elif code[1] == 0x1E:
                    import ipdb; ipdb.set_trace()
                    self.chip_state.i += self.chip_state.v[code[0] & 0xf]
                    if self.chip_state.i > 0xfff:
                        self.chip_state.v[0xf] = 1
                        self.chip_state.i &= 0xfff
                    else:
                        self.chip_state.v[0xf] = 0
                elif code[1] == 0x29:
                    addr = (5 * self.chip_state.v[code[0] & 0xf]) & 0xfff
                    self.chip_state.i = addr
                elif code[1] == 0x33:
                    # bcd vx
                    number = self.chip_state.v[code[0] &  0xf]
                    bcd = f"{number:03d}"
                    i = self.chip_state.i
                    self.chip_state.memory[i] = int(bcd[0])
                    self.chip_state.memory[i+1] = int(bcd[1])
                    self.chip_state.memory[i+2] = int(bcd[2])
                elif code[1] == 0x55:
                    # ld [i], vx
                    for index in range((code[0] & 0xf) + 1):
                        self.chip_state.memory[self.chip_state.i + index] = self.chip_state.v[index]
                    self.chip_state.i += (code[0] & 0xf) + 1
                elif code[1] == 0x65:
                    # load vx, [i]
                    for index in range((code[0] & 0xf) + 1):
                        self.chip_state.v[index] = self.chip_state.memory[self.chip_state.i + index]
                    self.chip_state.i += (code[0] & 0xf) + 1
    """
        


    